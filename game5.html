<!DOCTYPE html>
<html>
    <head>
        <title>Pac-Again - By Rafael Odon</title>
        <meta charset="UTF-8" />
        <style>
            body{
                margin:0px;
                padding: 0px;
                overflow: hidden;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas" style="border: 1px solid black"></canvas>
        <div style="display: hidden">
            Cycle: <span id="cycle"></span>
            <button id="pause">Play/Pause</button>
            <button id="next">&gt;&gt; Next</button>            
            </br>            
        </div>
        By Rafael Odon (odon.rafael@gmail.com)
    </body>
</html>    
<script>
// constants
var STEP=16;
var FPS=30;
var HALF_STEP=STEP/2;
var WIDTH=25;
var HEIGHT=26;
var PILLS_COUNT = 30;

//directions
var RIGHT = 0;
var DOWN = 1;
var LEFT = 2;
var UP = 3;

//scenes
var SCENE_PRESS_ANY_KEY = 1;
var SCENE_GAME = 2;
var SCENE_GAME_OVER = 3;
var SCENE_WIN  = 4;

//player states
var MOVING = 1;
var HIT = 2;
var DEAD = 3;

//ghosts states
var CHASE = 1;
var EXPLORE = 2;
var STUCKED = 3;

var DIRECTIONS = [
    { dx: 1, dy: 0}, // right    
    { dx: 0, dy: 1}, // down    
    { dx: -1, dy: 0}, // left        
    { dx: 0, dy: -1}, // up    
];

var SOUNDS = {
    beep : new Audio("beep.wav"),  
    hit: new Audio("hit.wav"),
    jump: new Audio("jump.wav"),
    collect: new Audio("collect.wav"),
    die: new Audio("die.wav"),
    over: new Audio("over.wav"),    
    win: new Audio("win.wav"),
    bg1: new Audio("bg1.wav"),
    bg2: new Audio("bg2.wav"),
}

var OBSTACLES = [    
    "#########################",
    "#########################",
    "#.......................#",
    "#.......................#",
    "#..###..#########..###..#",    
    "#.......................#",    
    "#.......................#",
    "#..########...########..#",    
    "#.......................#",    
    "#.......................#",
    "#..###..####.####..###..#",    
    "#.......#.......#.......#",
    "#..#....#.......#....#..#",
    "#..#.................#..#",    
    "#..#....#.......#....#..#",
    "#.......#.......#.......#",
    "#..###..####.####..###..#",    
    "#.......................#",    
    "#.......................#",
    "#..########...########..#",    
    "#.......................#",
    "#.......................#",    
    "#..###..#########..###..#",    
    "#.......................#",    
    "#.......................#",
    "#########################"
];

//global attributes

var enemies = [
    { id: 1, gx: 1, gy: 2, speed: 1, range: 5, direction: 0, color: "#F00" }, //red        
    { id: 2, gx: 23, gy: 2, speed: 1, range: 5, direction: 1, color: "#0F0" }, //green   
    { id: 3, gx: 23, gy: 23, speed: 1, range: 5, direction: 2, color: "#00F" }, //blue
    { id: 4, gx: 1, gy: 23, speed: 1, range: 5, direction: 3, color: "#F0F" }, //pink    
    { id: 5, gx: 1, gy: 12, speed: 1, range: 5, direction: 0, color: "#FF0" }, //yellow
    { id: 6, gx: 23, gy: 12, speed: 1, range: 5, direction: 1, color: "#0FF" }, //ciano        
];

var player = { x: 0, y: 0, speed: 2, direction: 0, color: "#FF0", lifes: 3, stucked: false, state: MOVING };

var cycle=0;
var pills = [];
var gameInterval = undefined;
var lastKeyDirection = 0;
var playing = true;
var scene = SCENE_PRESS_ANY_KEY;
var pillsCollected = 0;

window.onload = function(){

    var replay = function() {        
        this.currentTime = 0.09;        
        this.play();
    };

    SOUNDS.bg1.addEventListener('ended', replay, false);
    SOUNDS.bg2.addEventListener('ended', replay, false);
    SOUNDS.bg1.play();

    var canvas = document.getElementById("canvas");        

    var STEP_WIDTH = Math.floor((window.innerWidth / WIDTH) - ((window.innerWidth / WIDTH) % 4));
    var STEP_HEIGHT = Math.floor((window.innerHeight / HEIGHT) - ((window.innerHeight / HEIGHT) % 4));

    if(STEP_HEIGHT > STEP_WIDTH){
        STEP = STEP_WIDTH;                
    }else{
        STEP = STEP_HEIGHT;
    }  

    if(STEP < 16){
        STEP = 16;
    }  

    HALF_STEP = STEP / 2;

    canvas.width = WIDTH * STEP;
    canvas.height = HEIGHT * STEP;    

    var ctx = canvas.getContext("2d");    

    document.getElementById("pause").onclick = function(){
        togglePausePlay(ctx);
    };

    document.getElementById("next").onclick = function(){
        game(ctx);
    };

    document.onkeydown = keyDown;

    for(var i=0; i<PILLS_COUNT; i++){
        var pill = generateCoordinateOnEmptySpace();
        if(pills[pill.x] === undefined){
            pills[pill.x] = new Array(WIDTH);
        }
        pills[pill.x][pill.y] = 1;        
    }

    clearCanvas(ctx);

    enemies.forEach(function(enemy){
        enemy.x = enemy.gx * STEP + HALF_STEP;
        enemy.y = enemy.gy * STEP + HALF_STEP;
        drawEnemy(enemy, ctx);
    });

    player.x = WIDTH / 2 * STEP + STEP;
    player.y = HEIGHT / 2 * STEP;
    drawPlayer(player, ctx);

    gameInterval = setInterval(game, 1000/FPS, ctx);     
}

function game(ctx){  

    if(scene == SCENE_PRESS_ANY_KEY){

        if(SOUNDS.bg1.paused){
            SOUNDS.bg2.pause();
            SOUNDS.bg1.play();
        }

        clearCanvas(ctx);         
        displayDarkOverlay(ctx);               
        displayText(ctx, "PRESS ANY KEY...", canvas.width / 2, canvas.height / 2, STEP * 2);        
        displayLifeCount(ctx);
        drawPacman(ctx, canvas.width / 2, canvas.height / 3 * 2, STEP * 2);

    }else if(scene == SCENE_GAME){

        if(SOUNDS.bg2.paused){
            SOUNDS.bg1.pause();
            SOUNDS.bg2.play();
        }

        clearCanvas(ctx);    
        moveAndDrawEnemies(ctx);         
        movePlayer(ctx);        
        drawPlayer(player, ctx);
        displayText(ctx, "LIFES: "+player.lifes+"    PILLS: "+pillsCollected+" / "+PILLS_COUNT, canvas.width / 2, STEP, STEP);

    }else if(scene == SCENE_GAME_OVER){
        
        SOUNDS.bg1.pause();
        SOUNDS.bg2.pause();
        
        clearCanvas(ctx);   
        displayDarkOverlay(ctx);
        displayLifeCount(ctx); 
        displayText(ctx, "GAME OVER!", canvas.width / 2, canvas.height / 2, STEP * 3);
    }else if(scene == SCENE_WIN){

        if(!SOUNDS.bg2.paused){
            SOUNDS.bg2.pause();            
            SOUNDS.win.play();
        }                

        clearCanvas(ctx);
        displayDarkOverlay(ctx);        
        displayText(ctx, "LEVEL COMPLETED!", canvas.width / 2, canvas.height / 3, STEP * 2);        
        drawPacman(ctx, canvas.width / 2, canvas.height / 3 * 2, STEP * 2);
    }

    doCycle();
}

function drawPacman(ctx, x, y, scale){
    ctx.fillStyle = player.color;
        ctx.beginPath();    
        ctx.arc(x, y, scale, 0, Math.PI - 0.5);       
        ctx.fill();
        ctx.beginPath(); 
        ctx.arc(x, y, scale, 0, Math.PI + 0.5, true);
        ctx.fill();
}

function togglePausePlay(ctx){  
    if(gameInterval){
        clearInterval(gameInterval);
        gameInterval = undefined;

    }else{
        gameInterval = setInterval(game, 1000/FPS, ctx);     
    }    
}

function keyDown(e) {

    e = e || window.event;

    if(scene == SCENE_GAME){    
        if (e.keyCode == '38') { //up
            lastKeyDirection = UP;
        } else if (e.keyCode == '40') { //down
            lastKeyDirection = DOWN;
        } else if (e.keyCode == '37') { //left
            lastKeyDirection = LEFT;
        } else if (e.keyCode == '39') { //right
            lastKeyDirection = RIGHT;
        } 
    }

    if(scene == SCENE_PRESS_ANY_KEY){
        scene = SCENE_GAME;
        playing = true;
        player.x = canvas.width/2;
        player.y = canvas.height/2 + HALF_STEP;
        player.state = MOVING;
    }
    
}


function generateCoordinateOnEmptySpace(){
    var x=y=0;
    do{
        x = Math.floor(Math.random() * WIDTH);
        y = Math.floor(Math.random() * HEIGHT);
    }while(checkObstacle(x,y) || checkPill(x,y) || checkPlayer(x,y));
    return {x:x, y:y};
}

function clearCanvas(ctx){
    drawBackground(ctx);
    drawGrid(ctx)
    drawOBSTACLES(ctx);  
    drawPills(ctx);
}

function drawBackground(ctx){
    ctx.fillStyle = "black"
    ctx.fillRect(0,0,WIDTH*STEP,HEIGHT*STEP);
}

function drawPills(ctx){    
    for(var x=0; x<WIDTH; x++){
        for(var y=0; y<HEIGHT; y++){
            if(checkPill(x, y) ==  1){
                drawPill(x, y, ctx);
            }
        }
    }
}

function drawPill(x, y, ctx){       
    ctx.fillStyle = "black"
    var value = (Math.sin(cycle * Math.PI * 2 / FPS) / 2 + 0.5) * 0xFF | 0;        
    var grayscale = (value << 16) | (value << 8) | value;
    var color = '#' + grayscale.toString(16);

    ctx.fillStyle = color;    
    ctx.beginPath();
    ctx.arc(x*STEP+HALF_STEP, y*STEP+HALF_STEP, HALF_STEP*0.3, 0, 2*Math.PI);
    ctx.arc(x*STEP+HALF_STEP, y*STEP+HALF_STEP, HALF_STEP*0.3, 0, 2*Math.PI);
    ctx.fill();
}

function drawGrid(ctx){
    ctx.strokeStyle = "green";
    ctx.lineWIDTH = 1;
    for(var i=0; i<WIDTH; i++){        
        ctx.beginPath();
        ctx.moveTo(i*STEP,0);
        ctx.lineTo(i*STEP,HEIGHT*STEP);            
        ctx.stroke();
    }
    for(var j=0; j<HEIGHT; j++){
        ctx.beginPath();
        ctx.moveTo(0, j*STEP);
        ctx.lineTo(WIDTH*STEP, j*STEP);            
        ctx.stroke();
    }
}

function drawOBSTACLES(ctx){
    for(var y=0; y<HEIGHT; y++){
        for(var x=0; x<WIDTH; x++){            
            if(checkObstacle(x,y)){
                ctx.fillStyle = "green";
                ctx.fillRect(x*STEP,y*STEP,STEP,STEP);
            }
        }
    }
}

function checkPlayer(x,y){    
    return player.gx == x && player.gy == y;
}

function checkPill(x,y){
    return pills[x] && pills[x][y] == 1;    
}

function checkObstacle(x, y){
    return OBSTACLES[y] && OBSTACLES[y].charAt(x) == '#';
}

function checkEnemies(x, y, enemy){
    for(var i=0; i<enemies.length; i++){
        var other = enemies[i];        
        if((enemy == undefined || enemy.id != other.id) &&
            other.gx == x && other.gy == y){
            return true;
        }
    }
}

function displayDarkOverlay(ctx){
    ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
}

function displayText(ctx, text, x, y, size){                
    ctx.font = size+"px sans-serif";                  
    var realX = x - (ctx.measureText(text).width / 2);
    var realY = y + (size / 2);    

    ctx.fillStyle = "#333";
    ctx.fillText(text,realX-2,realY+2);    
    ctx.fillStyle = "#FFF";
    ctx.fillText(text,realX,realY);
}

function displayLifeCount(ctx, x, y, scale){
    if(x == undefined){

        ctx.fillStyle = "red";
        ctx.font = "30px sans-serif";
        var text = "LIFE x "+player.lifes;
        var x = (canvas.width - ctx.measureText(text).width) / 2;
        var y = (canvas.height) / 3;
        ctx.fillText(text, x, y)
    }
}

function doCycle(){
    cycle = ++cycle % Number.MAX_VALUE; 
    document.getElementById("cycle").innerText = ""+ cycle;  
}

function movePlayer(ctx){

    if(playing){
        if(player.state == MOVING){
            if((player.x + HALF_STEP) % STEP == 0 && (player.y + HALF_STEP) % STEP == 0){            
                player.direction = lastKeyDirection;
            }

            var destX = player.x + DIRECTIONS[player.direction].dx * player.speed * STEP / 8;
            var destY = player.y + DIRECTIONS[player.direction].dy * player.speed * STEP / 8;

            var gridX = parseInt((player.x + DIRECTIONS[player.direction].dx * (HALF_STEP + 0.5)) / STEP); 
            var gridY = parseInt((player.y + DIRECTIONS[player.direction].dy * (HALF_STEP + 0.5)) / STEP);                        

            if(!checkObstacle(gridX, gridY)){                           
                player.x = destX;
                player.y = destY;

                player.gx = gridX;
                player.gy = gridY;

                player.stucked = false;                  
            }else{
                if(!player.stucked){
                    SOUNDS.hit.play();
                    player.stucked = true;
                }
            }     

            if(checkEnemies(player.gx, player.gy)){            
                SOUNDS.bg2.pause();
                player.state = HIT;            
                SOUNDS.die.play();               
                player.lifes -= player.lifes > 0 ? 1 : 0;            
                playing = false;            
            }
            
            if(checkPill(player.gx, player.gy)){                        
                SOUNDS.collect.currentTime = 0;
                SOUNDS.collect.volume = 0.1;
                SOUNDS.collect.play();
                pillsCollected++;
                pills[player.gx][player.gy] = undefined;

                if(pillsCollected == PILLS_COUNT){
                    playing = false;
                    scene = SCENE_WIN;
                }
                //player.speed += player.speed >= 10 ? 0 : 1;
            }
        }

        //bloco no grid para debug
        //ctx.fillStyle = "red";
        //ctx.fillRect(gridX * STEP, gridY * STEP, STEP, STEP);                
    }

    if(player.state == DEAD){
        if(player.lifes > 0){
            scene = SCENE_PRESS_ANY_KEY;        
        }else{
            scene = SCENE_GAME_OVER;        
            SOUNDS.over.play();
        }
    }

    if(player.state == HIT){        
        player.aberturaBoca += 0.1; 
        if(player.aberturaBoca > 3){
            player.state = DEAD;
        }
    }
}

function moveAndDrawEnemies(ctx){
    enemies.forEach(function(enemy){
        if(playing){
            randomWalk(enemy);        
        }
        drawEnemy(enemy, ctx);
    });
}

function randomWalk(enemy){

    var r = Math.random();

    if((enemy.x - HALF_STEP) % STEP == 0 && (enemy.y - HALF_STEP) % STEP == 0){                                    

        var dx = player.gx - enemy.gx;
        var dy = player.gy - enemy.gy;
        var distance = Math.sqrt(dx*dx + dy*dy);        
        if(distance <= enemy.range){                                                                                
            enemy.state = CHASE;
            console.log(dx+", "+dy+", "+distance);
                        
            if(dx*dx > dy*dy){                
                if(dx > 0){
                    enemy.direction = RIGHT;                    
                    console.log("enemy "+enemy.id+" chasing RIGHT");
                }else{
                    enemy.direction = LEFT;
                    console.log("enemy "+enemy.id+" chasing LEFT");
                }
            }else{
                if(dy > 0){
                    enemy.direction = DOWN;
                    console.log("enemy "+enemy.id+" chasing DOWN");
                }else{
                    enemy.direction = UP;
                    console.log("enemy "+enemy.id+" chasing UP");                    
                }                
            }          
        }else{            
            enemy.state = EXPLORE;
        }                

        if(enemy.state && enemy.state == EXPLORE){                        
            if(r < 0.05){
                nextDirection(enemy);        
            }else if(r < 0.1){
                previousDirection(enemy);
            }        
        }
    }

    var tries = 0;
    while(true){
        var destX = enemy.x + DIRECTIONS[enemy.direction].dx * enemy.speed * STEP / 8;
        var destY = enemy.y + DIRECTIONS[enemy.direction].dy * enemy.speed * STEP / 8;

        var gridX = parseInt((enemy.x + DIRECTIONS[enemy.direction].dx * (HALF_STEP + 0.5)) / STEP); 
        var gridY = parseInt((enemy.y + DIRECTIONS[enemy.direction].dy * (HALF_STEP + 0.5)) / STEP);

        if(!checkObstacle(gridX, gridY)){                           
            enemy.x = destX;
            enemy.y = destY; 

            enemy.gx = gridX;
            enemy.gy = gridY;       

            break;
        }else{            
            if(r < 0.5){
                nextDirection(enemy);
            }else{
                previousDirection(enemy);
            }                    
        }
        tries++;
        if(tries > 4){
            break;
        }
    }
}

function oppositeDirection(enemy){
    enemy.direction = (enemy.direction + DIRECTIONS.length/2) % DIRECTIONS.length;
}

function nextDirection(enemy){
    enemy.direction = (enemy.direction + 1) % DIRECTIONS.length;    
}

function previousDirection(enemy){
    enemy.direction = (enemy.direction - 1 + DIRECTIONS.length) % DIRECTIONS.length;            
}

function drawEnemy(enemy, ctx){        

    ctx.fillStyle = enemy.color;    
    ctx.beginPath();
    ctx.arc(enemy.x, enemy.y, HALF_STEP, Math.PI, 0);
    ctx.fill();
   
    ctx.fillRect(enemy.x - HALF_STEP , enemy.y, STEP, HALF_STEP);    
  
    
    if(enemy.state == EXPLORE){
        ctx.fillStyle = "white";    
        ctx.beginPath();
        ctx.arc(enemy.x+0.70*STEP - HALF_STEP, enemy.y, STEP/4, 0, 2*Math.PI);        
        ctx.arc(enemy.x+0.30*STEP - HALF_STEP, enemy.y, STEP/4, 0, 2*Math.PI);
        ctx.fill();
        ctx.fillStyle = "black";    
        ctx.beginPath();
        ctx.arc(enemy.x+0.70*STEP + HALF_STEP*(1.0 + DIRECTIONS[enemy.direction].dx/5) - STEP, enemy.y+1*(1.0 + DIRECTIONS[enemy.direction].dy/5), STEP/8, 0, 2*Math.PI);
        ctx.arc(enemy.x+0.30*STEP + HALF_STEP*(1.0 + DIRECTIONS[enemy.direction].dx/5) - STEP, enemy.y+1*(1.0 + DIRECTIONS[enemy.direction].dy/5), STEP/8, 0, 2*Math.PI);
        ctx.fill();        
    }else if(enemy.state == CHASE){
        ctx.fillStyle = "white";    
        ctx.beginPath();
        ctx.arc(enemy.x+0.70*STEP - HALF_STEP, enemy.y, STEP/4, Math.PI, 1.75*Math.PI, true);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(enemy.x+0.30*STEP - HALF_STEP, enemy.y, STEP/4, 1.25*Math.PI, 0, true);
        ctx.fill();
        ctx.fillStyle = "black";    
        ctx.beginPath();
        ctx.arc(enemy.x+0.70*STEP + HALF_STEP*(1.0 + DIRECTIONS[enemy.direction].dx/5) - STEP, enemy.y+1*(1.0 + DIRECTIONS[enemy.direction].dy/5), STEP/12, 0, 2*Math.PI);
        ctx.arc(enemy.x+0.30*STEP + HALF_STEP*(1.0 + DIRECTIONS[enemy.direction].dx/5) - STEP, enemy.y+1*(1.0 + DIRECTIONS[enemy.direction].dy/5), STEP/12, 0, 2*Math.PI);
        ctx.fill();    
    }    

    
}

function drawPlayer(player, ctx){

    ctx.fillStyle = player.color;    
   
    var inicioArco = 0;
    var fimArco = 0;

    if(player.direction == RIGHT){        
        inicioArco = 1;
        fimArco = 0;
    }

    if(player.direction == LEFT){
        inicioArco = 0;
        fimArco = 1;
    }

    if(player.direction == DOWN){
        inicioArco = 1.5;
        fimArco = 0.5;
    }

    if(player.direction == UP){
        inicioArco = 0.5;
        fimArco = 1.5;
    }    

    if(player.state == MOVING){
        player.aberturaBoca = (Math.sin(cycle * Math.PI * 2 / FPS*2) / 2 + 0.5);        
    }
    
    ctx.beginPath();    
    ctx.arc(player.x, player.y, STEP/2, Math.PI * inicioArco, -player.aberturaBoca + Math.PI * fimArco);       
    ctx.fill();
    ctx.beginPath(); 
    ctx.arc(player.x, player.y, STEP/2, Math.PI * inicioArco, +player.aberturaBoca + Math.PI * fimArco, true);
    ctx.fill();
}
</script>